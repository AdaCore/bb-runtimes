MPC5200B Runtime
================

Runtimes Supported
------------------

* Ravenscar-SFP

Target Support
--------------

NXP MPC5200B

Using the runtimes
------------------

To use the runtime, copy them to the `<powerpc gnat install>/powerpc-elf/lib/gnat/`
folder. You can then select the runtime from the Toolchain pane of the Project
Properties dialog box in GPS or set the following in your GPR file:

   for Runtime ("ada") use "ravenscar-sfp-mpc5200";

Alternatively, you can locate the runtime in another directory and then in the
project file provide the full or relative path from the project file:

   for Runtime ("ada") use "/path/to/runtime/ravenscar-sfp-mpc5200";


Rebuilding the Runtime
----------------------

If you need to make changes to the runtime at any point to make changes to the
runtime's BSP you can rebuild it as follows:

For the Ravenscar runtimes: gprbuild -P ravenscar_build.gpr -j0

System Clocks
-------------

See package System.BB.Board_Parameters (`s-bbbopa.ads`) in the gnat directory
for the clock frequency declarations. The MPC5200 version of this package
defines two clock frequencies: XLB Frequency and IPB Frequency.

The XLB Clock drives the PowerPC Timebase Counter, the real-time counter used
by the runtime. By default, this clock is defined by the runtime to be 132Mhz,
with the clock frequency of the Timebase running at a quarter of the XLB Clock.
The frequency of the XLB Clock can be modified by updating
System.BB.Board_Parameters rebuilding the runtime.

The IPB Clock drives the Programmable Serial Controller and by default is
defined to be half the XLB Clock. The frequency is used by the runtime to
determine the PSC1 clock rate.

Startup Code
------------

The NXP MPC5200B runtime is designed to be loaded to and run from RAM by a
bootloader. As shipped, the runtime comes with two assembly files containing
the runtime startup code: `start.S` and `setup.S`. `start.S` provides the entry
of the runtime (_start_ram) that needs to be called by your bootloader.
The runtime is designed to return to the bootloader if your program terminates.
The return is performed via a blr instruction, so ensure _start_ram is called
in such a way that the link and stack registers contain the appropriate return
values at the start of _start_ram. If required, `start.S` can be replaced with
your own code.

`setup.S` provides the low-level setup that needs to be performed before the
high-level Ada code is called. This includes clearing the bss segments and
enabling and configuring the FPU. Like `start.S`, this code may be replaced
with your own code, but please contact AdaCore if you need to modify the FPU
settings as doing so may affect the conformance of the runtime to the Ada
Standard.

Memory
------

The memory layout is controlled by the linker script `ram.ld`, which can be
found inside the ld directory. By default, the script configures the system for
128 MiB of RAM and loads the application starting from 16#10_0000# to provide
space for any bootloader in the first 1MiB of RAM. If your requirements differ
from this you can either modify the `ram.ld` directly or provide your own
project-specific linker script via the `-T` linker switch and using the
`-XLOADER=USER` switch when building your application with GPRbuild.

The runtime expects the Memory Base Address Register (MBAR) to be located at
16#8000_0000#. If the bootloader or you relocate the MBAR, ensure you update
the MBAR constant in System.BB.Board_Parameters (`s-bbbopa.ads`) to reflect
its location.

The runtime enables the instruction cache during initialization. The data cache
should be enabled by the user after the MMU has been correctly configured.

Interrupts
----------

The MPC5200 Ravenscar runtime supports connecting interrupts generated by the
MPC5200 SIU Interrupt Controller to protected procedure handlers. The list of
interrupt names can be found in the package Ada.Interrupts.Names
(gnat/a-intnam.ads).

Due to the design of the SIU Interrupt Controller, all interrupts are mapped
to a single Ada Interrupt Priority. Additionally, critical interrupts are
routed to core_int.

Of the PowerPC core interrupt, the Decrementer, External Interrupt and System
Management vectors are reserved for runtime use. Handlers for the other PowerPC
core interrupts may be attached via the
System.BB.CPU_Specific.Install_Exception_Handler procedure:

   procedure Install_Exception_Handler
     (Service_Routine : System.Address;
      Vector          : Vector_Id);

The Service_Routine parameter is the address of your interrupt handler routine
and takes the form of:

   GNAT_Error_Handler (Trap : Vector_Id);

Interrupts a handled on a dedicated stack and the FPU is enabled, allowing the
use of floating-point instructions within an interrupt handler.

Power Management
----------------

By default, the runtime places the MPC5200's PowerPC core into the Doze power
management state when there is no running task. An application can change this
behavior by setting the corresponding power management bits in register HID0.
Note that it is not recommended to use the Sleep modes as it will stop the
timebase counter that is used as the runtime's time source.

Text_IO
-------

The runtimes provide a minimal version of the Ada.Text_IO package supporting
character- and string-based input and output routines. The bodies of the
Ada.Text_IO routines call through to a device-specific I/O package named
System.Text_IO. See the package body in the file `s-textio.adb` in the gnat
directory for more details.

By default System.Text_IO is configured to use PSC1 configured in UART mode
with the following settings: 115200 baud rate, 8-bits, no parity and 1 stop
bit. The package may be modified to change these settings.

Resources Used
--------------

The Ravenscar runtime libraries use the Timebase Counter and decrementer core
registers to implement Ada semantics for time, i.e., delay statements and
package Ada.Real_Time. See the package body for System.BB.Board_Support in the
file `gnat/s-bbsuti.adb`. Note that these registers are 32-bits wide, so
although the underlying time base value is 64-bits, the value must be read in
two separate instructions, that is, non-atomically, and then combined. This
results in the possibility of a race condition in which the upper half changes
after being read, apart from when the lower half is read. To deal with that
race condition a loop is used, but note that this requires multiple reads of
the two registers. See function Read_Clock in that package for the loop.
